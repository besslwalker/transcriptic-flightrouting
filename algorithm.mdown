## Analysis

This problem is reducible from the metric Steiner tree problem, which means it is NP complete.  

A greedy algorithm which simply adds legs as needed to fulfill tickets (removing legs then made redundant, similar to growing a minimum spanning tree) will provide a reasonable solution, but it will ignore any unticketed cities and therefore can't be guaranteed to be optimal.  (Unless all cities appear on tickets, in which case hurrah!)


## Algorithm

Since an optimal solution is required, a heuristic isn't good enough: a branch-and-bound approach is necessary.  The logically simplest element to branch on is the legs of the routing, since those are what we're concerned with finding.

The routing produced by the greedy algorithm briefly described above provides a reasonable starting upper bound.

### Brute-force branching -- suitable only for very small examples, but shakes out I/O and verification issues

0. The current best-known solution is None.

1. Use recursive branching to generate all possible INCLUDED / EXCLUDED combinations of legs.
  - when no UNDECIDED legs remain, evaluate the resulting graph: are all required cities reachable?
  - if the graph is valid, calculate the cost; if it is better than the best-known solution, it becomes the best-known solution.

(In my implementation, this was only reasonably timed for three or fewer cities.)

### Basic improvements - bounding, etc.

- Don't bother considering self-loop edges at all; start 'em out as EXCLUDED.
- If the current graph has a cost >= the best-known graph's cost, bail.
- If including the branching edge brings the cost over the best known, don't try that branch.
- Start the current-best solution with a simple take-all-the-tickets graph, as an upper bound.

### Polynomial time improvements based on shared cities.

(I consulted my advisor, who likes to play with algorithms.  These are all his ideas -- he got back to me really quickly before I even started thinking about the problem much!)

> Specifically, any time you include two edges that share a vertex, you can exclude another edge (and this effect should grow geometrically as you add edges -- you just need to make sure to add them in a good order.)

> Consider:

> 1: If you have A->B and B->C included, you can exclude A->C since that path is already available given the current set of flights.  In fact, you would actually mark it as "implicitly included" to simplify subsequent optimizations.

> 2a: If you have A->B and A->C then you can exclude BOTH B->C and C->B.  Why?  Because if they were added then one of the original edges would become redundant, and the branching process works such that once you include something, that path can only lead to solutions that keep that edge included.  Furthermore, any addition that would have made B->C or C->B at all possible can be excluded, and if either of these paths is a ticket you can backtrack right now.

> 2b: The opposite of point 2a also holds.  That is, if you have A->C and B->C then you can exclude BOTH A->B and B->A since they would each make one of the existing paths redundant.

> 3: Point number 2 has an interesting corollary.  Since we know all ticketed paths must be possible, if you have ticked path X->Y, then you cannot have both A->X and A->Y directly in the answer set.  If you did, you wouldn't need the A->Y because there would have been another route to go.  Ahh... the one exception to this rule is if the X->Y path goes through A.  So what this says is that it is easier to make rules about DIRECT paths.  OR indirect paths that are already included since we'll know what else they go through.


> That covers all of the possibilities for when two included edges share a vertex.

### Polynomial time improvements based on required origins & destinations

4a. If B is the destination of some ticket, and excluding A->B leaves only C->B as a possible path to B, we must include C->B.

4b. If A is the origin of some ticket, and excluding A->B leaves only A->C as a possible path from A, we must include A->C.